## The following code contains work of the United States Government and is not subject to domestic copyright protection under 17 USC ยง 105.
## Additionally, we waive copyright and related rights in the utilized code worldwide through the CC0 1.0 Universal public domain dedication.
from ipaddress import IPv4Address
from typing import Optional

from CybORG.Simulator.Actions.ConcreteActions.ExploitActions.ExploitAction import ExploitAction
from CybORG.Shared.Enums import ProcessType, DecoyType
from CybORG.Shared.Observation import Observation
from CybORG.Simulator.Host import Host
from CybORG.Simulator.Process import Process
from CybORG.Simulator.State import State
from CybORG.Simulator.Session import RedAbstractSession
from CybORG.Simulator.Actions.Action import lo


class SSHBruteForce(ExploitAction):
    def __init__(self, ip_address: IPv4Address, agent: str, session: int):
        super().__init__(session=session, agent=agent, ip_address=ip_address)
        self.wordlist_length = 10
        self._port = 22
        self.process_type = 'SSH'

    def execute(self, state: State) -> Observation:
        """Attempts to exploit host, establishing a session on it"""
        if type(state.sessions[self.agent][self.session]) is not RedAbstractSession or self.ip_address not in \
            state.sessions[self.agent][self.session].ports:
            return Observation(success=False)
        obs = Observation(False)

        exploit_data = self._get_exploit_data(state, self.process_type, self._port)
        vuln_proc = exploit_data.get('vuln_proc')
        if vuln_proc is None:
            return obs

        target_process = self._get_target_process(self._port, self.process_type)
        obs.add_process(**target_process)

        target_host = exploit_data['target_host']
        local_port = target_host.get_ephemeral_port()
        user = self._get_bruteforceable_user(target_host)
        self._create_brute_force_event(local_port, **exploit_data)
        if user is None:
            return obs

        is_exploit_decoy = bool(vuln_proc.decoy_type & DecoyType.EXPLOIT)
        if is_exploit_decoy:
            self._create_exploit_decoy_event(local_port)
            obs.add_interface_info(ip_address=str(self.ip_address))
            return obs

        new_session = self._create_new_session(state, obs, local_port, user=user, \
                session_type='SSH', **exploit_data)
        self._create_new_session_event(new_session, local_port, **exploit_data)

        session_info = self._get_session_info(new_session, user)
        obs.add_session_info(**session_info)

        source_conn, target_conn = self._get_connections(local_port, **exploit_data)
        obs.add_process(**source_conn)
        obs.add_process(**target_conn)

        system_info = self._get_system_info(target_host)
        obs.add_system_info(**system_info)
        obs.set_success(True)

        if self.ip_address != lo and obs.data['success'] == True:
            hostname = obs.data[str(self.ip_address)]["System info"]["Hostname"]
            os = obs.data[str(self.ip_address)]["System info"]["OSType"]
            state.sessions[self.agent][self.session].addos(hostname, os)
        return obs

    def _get_bruteforceable_user(self, target_host):
        user = None
        for u in target_host.users:
            if u.bruteforceable:
                user = u
                break
        
        return user

    def _create_brute_force_event(self, local_port, target_host, from_ip, **kwargs):
        for i in range(self.wordlist_length):
            event = {
                    'remote_address': from_ip,
                    'remote_port': local_port,
                    'local_address': self.ip_address,
                    'local_port': self._port
                    }

            target_host.events['NetworkConnections'].append(event)

    def _get_session_info(self, new_session, user):
        session_info = {
                'username': user.username,
                'hostid': str(self.ip_address),
                'session_id': new_session.ident,
                'session_type': new_session.session_type,
                'agent': self.agent
                }

        return session_info

    def _get_connections(self, local_port, from_ip, **kwargs):
        source_connection = {
                'hostid': str(from_ip),
                'local_address': from_ip,
                'remote_address': str(self.ip_address),
                'local_port': local_port,
                'remote_port': self._port,
                }

        target_connection = {
                'hostid': str(self.ip_address),
                'local_address': str(self.ip_address),
                'remote_address': from_ip,
                'local_port': self._port,
                'remote_port': local_port,
                'Process Type': 'ssh'
                }

        return source_connection, target_connection

    def _create_new_session(self, state, obs, local_port, user, session, from_ip, target_host, \
                    vuln_proc, extension, path, session_type='red_reverse_shell', **kwargs):
        source_connection = {
                "local_port": 4444,
            "Application Protocol": "tcp",
            "local_address": from_ip,
            "remote_address": self.ip_address,
            "remote_port": local_port
            }
        source_process = state.hosts[session.hostname].get_process(session.pid)
        source_process.connections.append(source_connection)

        target_connection = {
            "local_port": local_port,
            "Application Protocol": "tcp",
            "remote_address": from_ip,
            "remote_port": 4444,
            "local_address": self.ip_address
            }

        new_file = target_host.add_file(
                name=f'cmd.{extension}',
                path=path,
                user=user,
                user_permissions=7,
                density=0.9,
                signed=False
                )
        proc = target_host.add_process(name=new_file.name, ppid=1, path=new_file.path, \
                user=user)
        proc.connections.append(target_connection)

        is_sandbox = bool(vuln_proc.decoy_type & DecoyType.SANDBOXING_EXPLOIT)
        new_session = state.add_session(
                host=target_host.hostname,
                agent=self.agent,
                user=user,
                session_type=session_type,
                parent=self.session,
                process=proc.pid,
                is_escalate_sandbox=is_sandbox
                )

        return new_session